<script>
    // 実際の返済記録（年を修正: 2024→2025）
    const paymentHistory = [
        { date: '2025-11-06', amount: 10000 },
        { date: '2025-11-17', amount: 45000 },
        { date: '2025-11-27', amount: 15000 },
        { date: '2025-12-08', amount: 10000 },
        { date: '2025-12-24', amount: 115000 },
        { date: '2025-12-28', amount: 25000 },
        { date: '2025-12-29', amount: 15000 },
        { date: '2026-01-06', amount: 10000 },
        { date: '2026-01-23', amount: 45000 },
        { date: '2026-01-27', amount: 15000 },
        { date: '2026-02-02', amount: 134977 },
        { date: '2026-02-06', amount: 10000 }
    ];
    
    // 検算用: 2026/2/14時点の正しい残高
    const EXPECTED_BALANCE_2026_02_14 = 681840.00;

    // 固定パラメータ
    const INITIAL_LOAN = 1086101.84;
    const BASE_DATE = new Date('2025-11-06');
    const INTEREST_RATE = 18.0;

    // 状態管理
    const state = {
        loanAmount: INITIAL_LOAN,
        baseDate: BASE_DATE,
        interestRate: INTEREST_RATE,
        paymentHistory: paymentHistory,
        plannedPayments: [], // 返済予定リスト
        customAvgPayment: null, // カスタム平均返済額（null = 自動計算）
        plan: [],
        summary: { total: 0, interest: 0, payments: 0 }
    };

    // 要素の取得
    const els = {
        duration: document.getElementById('duration-display'),
        completionDateHeader: document.getElementById('completion-date-header'),
        todayDate: document.getElementById('today-date'),
        todayBalance: document.getElementById('today-balance'),
        dailyInterest: document.getElementById('daily-interest'),
        completionPercentage: document.getElementById('completion-percentage'),
        progressBarFill: document.getElementById('progress-bar-fill'),
        principalPaid: document.getElementById('principal-paid'),
        principalRemaining: document.getElementById('principal-remaining'),
        totalPay: document.getElementById('total-payment'),
        totalInt: document.getElementById('total-interest'),
        avgPaymentInput: document.getElementById('avg-payment-input'),
        combinedChart: document.getElementById('combined-chart'),
        combinedLabels: document.getElementById('combined-labels'),
        tbody: document.getElementById('table-body')
    };

    // フォーマット関数（小数点切り上げ）
    const fmt = (n) => Math.ceil(n).toLocaleString();
    
    // 日付フォーマット
    const fmtDate = (date) => {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}/${m}/${d}`;
    };
    
    // 日付フォーマット（短縮版: YY/MM）
    const fmtDateShort = (date) => {
        const y = String(date.getFullYear()).slice(-2); // 下2桁
        const m = date.getMonth() + 1;
        return `${y}/${m}`;
    };

    // 日数計算
    const daysBetween = (date1, date2) => {
        const d1 = new Date(date1);
        const d2 = new Date(date2);
        d1.setHours(0, 0, 0, 0);
        d2.setHours(0, 0, 0, 0);
        const diff = d2 - d1;
        return Math.floor(diff / (1000 * 60 * 60 * 24));
    };

    // 全ての返済（実績+予定）を取得
    const getAllPayments = () => {
        const allPayments = [
            ...state.paymentHistory.map(p => ({ ...p, isPlanned: false })),
            ...state.plannedPayments.map(p => ({ ...p, isPlanned: true }))
        ];
        return allPayments.sort((a, b) => new Date(a.date) - new Date(b.date));
    };

    // 今日の残高を計算（実際の返済記録+予定に基づく）
    const calculateTodayBalance = () => {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const rate = state.interestRate / 100;
        let balance = state.loanAmount;
        
        // 全ての返済（実績+予定）を取得
        const payments = getAllPayments();
        
        let lastDate = new Date(state.baseDate);
        lastDate.setHours(0, 0, 0, 0);
        
        // 各返済の処理
        for (const payment of payments) {
            const paymentDate = new Date(payment.date);
            paymentDate.setHours(0, 0, 0, 0);
            
            if (paymentDate > today) break;
            
            // lastDateからpaymentDateまでの日数
            const days = daysBetween(lastDate, paymentDate);
            
            // 単利計算: 元金 × 0.18 × 日数 ÷ 365
            const interest = balance * rate * days / 365;
            
            // 返済前残高 = 前回残高 + 利息
            const balanceBeforePayment = balance + interest;
            
            // 返済後残高 = 返済前残高 - 返済額
            balance = balanceBeforePayment - payment.amount;
            
            lastDate = new Date(paymentDate);
        }
        
        // 最後の返済日（または基準日）から今日までの日数
        const daysFromLast = daysBetween(lastDate, today);
        const accruedInterest = balance * rate * daysFromLast / 365;
        
        return {
            balance: balance,
            daysAccrued: daysFromLast,
            interestAccrued: accruedInterest,
            totalBalance: balance + accruedInterest
        };
    };

    // 計算ロジック（返済記録+予定に基づく）
    function calculate() {
        const annualRate = state.interestRate / 100;
        let balance = state.loanAmount;
        let totalInt = 0;
        let totalPaid = 0;

        state.plan = [];

        // 全ての返済（実績+予定）を取得
        const payments = getAllPayments();

        let lastDate = new Date(state.baseDate);
        lastDate.setHours(0, 0, 0, 0);

        payments.forEach((payment, index) => {
            const paymentDate = new Date(payment.date);
            paymentDate.setHours(0, 0, 0, 0);
            
            // 前回の日付から今回の返済日までの日数
            const days = daysBetween(lastDate, paymentDate);
            
            // 単利計算: 元金 × 0.18 × 日数 ÷ 365
            const interest = balance * annualRate * days / 365;
            
            // 返済前残高
            const balanceBeforePayment = balance + interest;
            
            // 返済後残高
            balance = balanceBeforePayment - payment.amount;
            
            // 実際に支払った利息分（返済額のうち利息に充当された額）
            const interestPaid = Math.min(interest, payment.amount);
            const principalPaid = payment.amount - interestPaid;
            
            totalInt += interestPaid;
            totalPaid += payment.amount;

            state.plan.push({
                index: index,
                date: new Date(paymentDate),
                payment: payment.amount,
                principal: principalPaid,
                interest: interestPaid,
                balance: balance,
                daysElapsed: days,
                isPlanned: payment.isPlanned
            });

            lastDate = new Date(paymentDate);
        });

        state.summary.total = totalPaid;
        state.summary.interest = totalInt;
        state.summary.payments = state.plan.length;

        render();
    }
    
    // 将来予測を計算（月平均返済額で返済を続けた場合）
    function calculateForecast() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        // 前月の最終日を取得
        const lastMonth = new Date(today.getFullYear(), today.getMonth(), 0);
        
        const monthlyData = {};
        
        // 実績のみを集計（予定は除外）
        state.plan.filter(row => !row.isPlanned).forEach(row => {
            const date = new Date(row.date);
            const day = date.getDate();
            
            // 1-5日の場合は前月として扱う
            let displayDate = new Date(date);
            if (day >= 1 && day <= 5) {
                displayDate.setMonth(displayDate.getMonth() - 1);
            }
            
            // 前月までのデータのみを集計
            if (displayDate <= lastMonth) {
                const monthKey = `${displayDate.getFullYear()}-${String(displayDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = 0;
                }
                monthlyData[monthKey] += row.payment;
            }
        });
        
        const monthlyPayments = Object.values(monthlyData);
        
        // 自動計算の月平均
        const calculatedAvgPayment = monthlyPayments.length > 0
            ? monthlyPayments.reduce((sum, p) => sum + p, 0) / monthlyPayments.length
            : 0;
        
        // カスタム値があればそれを使用、なければ自動計算値
        const avgMonthlyPayment = state.customAvgPayment !== null 
            ? state.customAvgPayment 
            : calculatedAvgPayment;
        
        // 現在の残高から開始
        const todayData = calculateTodayBalance();
        let balance = todayData.balance;
        
        // 最後の返済日を取得
        const lastPaymentDate = state.plan.length > 0 
            ? new Date(state.plan[state.plan.length - 1].date)
            : new Date(state.baseDate);
        
        // 今日から最後の返済日までの利息を加算
        const daysFromLastPayment = daysBetween(lastPaymentDate, today);
        const accruedInterest = balance * (state.interestRate / 100) * daysFromLastPayment / 365;
        balance += accruedInterest;
        
        const forecast = [];
        const annualRate = state.interestRate / 100;
        let currentDate = new Date(today);
        let monthCount = 0;
        const MAX_MONTHS = 120; // 10年上限
        
        while (balance > 0 && monthCount < MAX_MONTHS) {
            // 次の月の1日
            currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
            
            // 1ヶ月分の利息（概算として30日）
            const interest = balance * annualRate * 30 / 365;
            
            let payment = avgMonthlyPayment;
            
            // 完済チェック
            if (balance + interest <= payment) {
                payment = balance + interest;
            }
            
            const principal = payment - interest;
            balance -= principal;
            
            if (balance < 0) balance = 0;
            
            forecast.push({
                date: new Date(currentDate),
                payment: payment,
                principal: principal,
                interest: interest,
                balance: balance
            });
            
            monthCount++;
        }
        
        return {
            avgMonthlyPayment: avgMonthlyPayment,
            forecast: forecast,
            completionDate: forecast.length > 0 ? forecast[forecast.length - 1].date : null,
            remainingMonths: forecast.length
        };
    }

    // 描画関数
    function render() {
        // 今日の残高計算
        const todayData = calculateTodayBalance();
        const today = new Date();
        
        els.todayDate.textContent = `${fmtDate(today)} 時点の残高`;
        els.todayBalance.textContent = `¥${fmt(todayData.totalBalance)}`;
        els.dailyInterest.textContent = `元金 ¥${fmt(todayData.balance)} + 未払利息 ¥${fmt(todayData.interestAccrued)} (${todayData.daysAccrued}日分)`;

        // 完済率の計算
        const initialLoan = state.loanAmount;
        const currentPrincipal = todayData.balance;
        const principalPaid = initialLoan - currentPrincipal;
        const completionRate = (principalPaid / initialLoan) * 100;
        
        // 完済率の表示（小数点第2位まで）
        els.completionPercentage.textContent = `${completionRate.toFixed(2)}%`;
        els.progressBarFill.style.width = `${completionRate}%`;
        els.principalPaid.textContent = `¥${fmt(principalPaid)}`;
        els.principalRemaining.textContent = `¥${fmt(currentPrincipal)}`;

        // 将来予測を計算
        const forecastData = calculateForecast();
        
        // 月平均返済額を入力欄に表示
        els.avgPaymentInput.value = Math.ceil(forecastData.avgMonthlyPayment);
        
        // 完済予定日と期間（ヘッダーに表示）
        if (forecastData.completionDate) {
            els.completionDateHeader.textContent = fmtDate(forecastData.completionDate);
            
            const years = Math.floor(forecastData.remainingMonths / 12);
            const months = forecastData.remainingMonths % 12;
                
            els.duration.textContent = years > 0 
                ? `${years}年${months}ヶ月` 
                : `${months}ヶ月`;
        } else {
            els.completionDateHeader.textContent = '計算不能';
            els.duration.textContent = '要増額';
        }
        
        els.totalPay.textContent = `¥${fmt(state.summary.total)}`;
        els.totalInt.textContent = `¥${fmt(state.summary.interest)}`;

        renderCombinedChart(forecastData.forecast);
        renderTable();
    }

    // 統合グラフ描画（実績+予測）
    function renderCombinedChart(forecastData) {
        const actualData = state.plan;
        
        if (actualData.length === 0) {
            els.combinedChart.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#9ca3af" font-size="5">データなし</text>';
            els.combinedLabels.innerHTML = '';
            return;
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const currentMonthKey = `${today.getFullYear()}/${String(today.getMonth() + 1).padStart(2, '0')}`;

        // 実績データを月ごとに集計（1-5日は前月扱い）
        // 返済予定も実績として扱う
        const actualMonthly = {};
        actualData.forEach(row => {
            const date = new Date(row.date);
            const day = date.getDate();
            
            // 1-5日の場合は前月として扱う
            let displayDate = new Date(date);
            if (day >= 1 && day <= 5) {
                displayDate.setMonth(displayDate.getMonth() - 1);
            }
            
            const monthKey = `${displayDate.getFullYear()}/${String(displayDate.getMonth() + 1).padStart(2, '0')}`;
            const displayKey = fmtDateShort(displayDate);
            
            if (!actualMonthly[monthKey]) {
                actualMonthly[monthKey] = { 
                    payment: 0, 
                    interest: 0, 
                    principal: 0, 
                    isActual: true, 
                    displayMonth: displayKey,
                    isCurrentMonth: monthKey === currentMonthKey
                };
            }
            actualMonthly[monthKey].payment += row.payment;
            actualMonthly[monthKey].interest += row.interest;
            actualMonthly[monthKey].principal += row.principal;
        });

        // 予測データを月ごとに変換（返済予定がない月のみ）
        const forecastMonthly = {};
        if (forecastData && forecastData.length > 0) {
            forecastData.forEach(row => {
                const date = new Date(row.date);
                const monthKey = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}`;
                const displayKey = fmtDateShort(date);
                
                // その月に実績（返済予定含む）がない場合のみ予測を追加
                if (!actualMonthly[monthKey]) {
                    forecastMonthly[monthKey] = {
                        payment: row.payment,
                        interest: row.interest,
                        principal: row.principal,
                        isActual: false,
                        displayMonth: displayKey,
                        isCurrentMonth: monthKey === currentMonthKey
                    };
                }
            });
        }

        // 全データを結合
        const allMonths = [...Object.keys(actualMonthly), ...Object.keys(forecastMonthly)];
        const uniqueMonths = [...new Set(allMonths)].sort();
        
        // 月平均返済額を取得（当月の予測バー用）
        const forecastDataObj = calculateForecast();
        const avgPayment = forecastDataObj.avgMonthlyPayment;
        
        const chartData = uniqueMonths.map(month => {
            const actual = actualMonthly[month];
            const forecast = forecastMonthly[month];
            const isCurrentMonth = month === currentMonthKey;
            
            if (actual && isCurrentMonth) {
                // 当月：実績あり、予測も追加
                return { 
                    month, 
                    payment: actual.payment,
                    interest: actual.interest,
                    principal: actual.principal,
                    isActual: true,
                    isCurrentMonth: true,
                    avgPayment: avgPayment, // 予測額
                    displayMonth: actual.displayMonth
                };
            } else if (actual) {
                // 過去月：実績のみ
                return { 
                    month, 
                    payment: actual.payment,
                    interest: actual.interest,
                    principal: actual.principal,
                    isActual: true,
                    isCurrentMonth: false,
                    displayMonth: actual.displayMonth
                };
            } else if (forecast) {
                // 未来月：予測のみ
                return { 
                    month, 
                    payment: forecast.payment,
                    interest: forecast.interest,
                    principal: forecast.principal,
                    isActual: false,
                    isCurrentMonth: false,
                    displayMonth: forecast.displayMonth
                };
            }
        }).filter(Boolean);

        const maxPay = Math.max(...chartData.map(d => d.payment || 0)) * 1.1;
        if (maxPay === 0) return;

        let svgContent = '';
        // グリッド線
        [0, 0.5, 1].forEach(t => {
            const y = 100 - (t * 100);
            svgContent += `<line x1="0" y1="${y}" x2="100" y2="${y}" stroke="#e5e7eb" stroke-width="0.5" vector-effect="non-scaling-stroke" />`;
        });

        // バー
        const count = chartData.length;
        const gap = count > 40 ? 0 : 1;
        const barW = (100 / count) - gap;

        chartData.forEach((d, i) => {
            const x = (i * (100 / count)) + (gap / 2);
            
            if (d.isCurrentMonth && d.isActual && d.avgPayment && d.avgPayment > 0) {
                // 当月：予測バー（薄色・背景）+ 実績部分（濃色・前景）を重ねる
                
                // 予測バーの高さを計算（平均返済額で）
                const avgInterestEstimate = d.avgPayment * 0.1; // 概算10%を利息とする
                const avgPrincipalEstimate = d.avgPayment - avgInterestEstimate;
                
                const avgPH = Math.max(0, (avgPrincipalEstimate / maxPay) * 100);
                const avgIH = (avgInterestEstimate / maxPay) * 100;
                
                // 1. まず予測バー（薄色・背景）を描画
                svgContent += `<rect x="${x}%" y="${100 - (avgPH + avgIH)}%" width="${barW}%" height="${avgIH}%" fill="#fed7aa" />`;
                svgContent += `<rect x="${x}%" y="${100 - avgPH}%" width="${barW}%" height="${avgPH}%" fill="#93c5fd" />`;
                
                // 2. その上に実績部分（濃色・前景）を重ねる
                const pH = Math.max(0, (d.principal / maxPay) * 100);
                const iH = (d.interest / maxPay) * 100;
                
                if (iH > 0) {
                    svgContent += `<rect x="${x}%" y="${100 - (pH + iH)}%" width="${barW}%" height="${iH}%" fill="#fb923c" />`;
                }
                if (pH > 0) {
                    svgContent += `<rect x="${x}%" y="${100 - pH}%" width="${barW}%" height="${pH}%" fill="#3b82f6" />`;
                }
            } else if (d.isActual) {
                // 過去月または未来の返済予定：実績（濃色）のみ
                const pH = Math.max(0, (d.principal / maxPay) * 100);
                const iH = (d.interest / maxPay) * 100;
                
                svgContent += `<rect x="${x}%" y="${100 - (pH + iH)}%" width="${barW}%" height="${iH}%" fill="#fb923c" />`;
                if (d.principal > 0) {
                    svgContent += `<rect x="${x}%" y="${100 - pH}%" width="${barW}%" height="${pH}%" fill="#3b82f6" />`;
                }
            } else {
                // 未来月：予測（薄色）のみ
                const pH = Math.max(0, (d.principal / maxPay) * 100);
                const iH = (d.interest / maxPay) * 100;
                
                svgContent += `<rect x="${x}%" y="${100 - (pH + iH)}%" width="${barW}%" height="${iH}%" fill="#fed7aa" />`;
                if (d.principal > 0) {
                    svgContent += `<rect x="${x}%" y="${100 - pH}%" width="${barW}%" height="${pH}%" fill="#93c5fd" />`;
                }
            }
        });

        els.combinedChart.innerHTML = svgContent;
        
        // 年月ラベルを全て表示
        let labelsHtml = '';
        chartData.forEach(d => {
            labelsHtml += `<span>${d.displayMonth}</span>`;
        });
        els.combinedLabels.innerHTML = labelsHtml;
    }

    // テーブル描画
    function renderTable() {
        const fragment = document.createDocumentFragment();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        if (state.plan.length === 0) {
            els.tbody.innerHTML = '<div style="padding:20px; text-align:center; color:#9ca3af;">返済記録がありません</div>';
            return;
        }

        // plannedPaymentsのインデックスを追跡
        let plannedIndex = 0;

        // 全ての返済を表示（実績+予定）
        state.plan.forEach((row, index) => {
            const div = document.createElement('div');
            const isCompleted = row.date <= today;
            const isPlanned = row.isPlanned;
            
            // 過去の実績は薄緑、返済予定は黄色
            if (isCompleted && !isPlanned) {
                div.className = 'row completed';
            } else if (isPlanned) {
                div.className = 'row planned';
            } else {
                div.className = 'row';
            }

            // 5つのセルを作成
            const dateCell = document.createElement('div');
            dateCell.textContent = fmtDate(row.date);
            
            const paymentCell = document.createElement('div');
            paymentCell.style.cssText = 'border-left:1px solid #f3f4f6; font-weight: 600;';
            paymentCell.textContent = fmt(row.payment);
            
            const interestCell = document.createElement('div');
            interestCell.className = 'text-orange';
            interestCell.style.cssText = 'border-left:1px solid #f3f4f6;';
            interestCell.textContent = fmt(row.interest);
            
            const principalCell = document.createElement('div');
            principalCell.className = 'text-blue';
            principalCell.style.cssText = 'border-left:1px solid #f3f4f6;';
            principalCell.textContent = fmt(row.principal);
            
            const balanceCell = document.createElement('div');
            balanceCell.className = 'text-gray';
            balanceCell.style.cssText = 'border-left:1px solid #f3f4f6; position: relative; display: flex; align-items: center; justify-content: flex-end; gap: 8px;';
            
            // 残高テキストをspan要素で作成
            const balanceText = document.createElement('span');
            balanceText.textContent = fmt(row.balance);
            balanceCell.appendChild(balanceText);
            
            div.appendChild(dateCell);
            div.appendChild(paymentCell);
            div.appendChild(interestCell);
            div.appendChild(principalCell);
            div.appendChild(balanceCell);
            
            // 削除ボタンを追加（返済予定のみ） - 残高セルの中に配置
            if (isPlanned) {
                const currentPlannedIndex = plannedIndex;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '削除';
                deleteBtn.type = 'button';
                deleteBtn.style.cssText = 'background: #ef4444; color: white; border: none; padding: 4px 10px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; cursor: pointer; white-space: nowrap;';
                
                deleteBtn.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (confirm('この返済予定を削除しますか？')) {
                        state.plannedPayments.splice(currentPlannedIndex, 1);
                        calculate();
                    }
                };
                
                balanceCell.appendChild(deleteBtn);
                plannedIndex++;
            }
            
            fragment.appendChild(div);
        });
        
        els.tbody.innerHTML = '';
        els.tbody.appendChild(fragment);
    }

    // 平均返済額を更新
    window.updateAvgPayment = function() {
        const value = Number(els.avgPaymentInput.value);
        if (isNaN(value) || value < 0) {
            alert('正しい金額を入力してください');
            return;
        }
        
        state.customAvgPayment = value;
        render(); // グラフを再描画
    };
    
    // 平均返済額を自動計算に戻す
    window.resetAvgPayment = function() {
        state.customAvgPayment = null;
        render(); // グラフを再描画
    };
    
    // 初期計算
    calculate();
    
    // 返済予定を追加
    window.addPaymentPlan = function() {
        const dateInput = document.getElementById('new-payment-date');
        const amountInput = document.getElementById('new-payment-amount');
        
        const date = dateInput.value;
        const amount = Number(amountInput.value);
        
        if (!date) {
            alert('返済予定日を入力してください');
            return;
        }
        
        if (!amount || amount <= 0) {
            alert('正しい返済金額を入力してください');
            return;
        }
        
        const planDate = new Date(date);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        if (planDate < today) {
            alert('未来の日付を入力してください');
            return;
        }
        
        // 返済予定を追加
        state.plannedPayments.push({
            date: date,
            amount: amount
        });
        
        // 日付でソート
        state.plannedPayments.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // フォームをクリア
        dateInput.value = '';
        amountInput.value = '';
        
        // 再計算
        calculate();
    };
    
    // 日付が変わったら自動更新（1分ごとにチェック）
    setInterval(() => {
        const now = new Date();
        if (now.getHours() === 0 && now.getMinutes() === 0) {
            render();
        }
    }, 60000);
</script>
